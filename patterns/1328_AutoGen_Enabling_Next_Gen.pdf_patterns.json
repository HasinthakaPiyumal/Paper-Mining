[
  {
    "Pattern Name": "Conversable Agents",
    "Problem": "Designing individual agents that are capable, reusable, customizable, and effective in multi-agent collaboration within LLM applications.",
    "Context": "Building multi-agent LLM applications where agents need to interact, provide feedback, and make progress through conversation.",
    "Solution": "Implement a generic agent design that can leverage LLMs, human inputs, tools, or a combination thereof. Make agents 'conversable' so they can receive, react, and respond to messages, maintaining internal context. Allow for convenient creation of agents with different roles or responsibilities through configuration or extension.",
    "Result": "Enables modular combination of broad LLM capabilities, allows agents to hold multi-turn conversations autonomously or with human involvement, and facilitates the creation of specialized agents for diverse tasks.",
    "Related Patterns": [
      "Conversation Programming",
      "Unified Conversation Interfaces and Autoreply Mechanisms",
      "Composable Conversation Patterns"
    ],
    "Uses": "General multi-agent LLM application development, role-playing scenarios, task-specific agents (e.g., AssistantAgent, UserProxyAgent)."
  },
  {
    "Pattern Name": "Conversation Programming",
    "Problem": "Streamlining the development of complex LLM applications that rely on multi-agent interactions and require flexible control over conversation flow and agent actions.",
    "Context": "Developing intricate multi-agent systems where workflows are best expressed as inter-agent conversations rather than rigid sequences.",
    "Solution": "Adopt a programming paradigm centered around inter-agent conversations. This involves two primary steps: 1) defining a set of conversable agents with specific capabilities and roles, and 2) programming the interaction behavior between agents via conversation-centric computation and control, using a fusion of natural language and code.",
    "Result": "Simplifies and unifies complex LLM applications, facilitates intuitive reasoning about complex workflows through agent actions and message passing, and supports flexible multi-agent conversation patterns.",
    "Related Patterns": [
      "Conversable Agents",
      "Unified Conversation Interfaces and Autoreply Mechanisms",
      "Control by Fusion of Programming and Natural Language",
      "Composable Conversation Patterns"
    ],
    "Uses": "General multi-agent LLM application development, defining complex workflows, agent interaction scripting."
  },
  {
    "Pattern Name": "Unified Conversation Interfaces and Autoreply Mechanisms",
    "Problem": "Managing the communication and control flow in multi-agent systems in a decentralized, modular, and unified way, without requiring a separate, complex control plane.",
    "Context": "Agents needing to send, receive, and generate replies in multi-turn conversations, where the conversation flow should be naturally induced by agent interactions.",
    "Solution": "Provide low-level, unified conversation interfaces (`send/receive`, `generate_reply`, `register_reply`). Implement a default 'agent autoreply mechanism' where an agent automatically invokes `generate_reply` and sends a response after receiving a message, unless a termination condition is met. Allow registration of custom reply functions to customize agent behavior.",
    "Result": "Enables automated agent chats, simplifies workflow definition, and supports dynamic, conversation-driven control flow.",
    "Related Patterns": [
      "Conversable Agents",
      "Conversation Programming",
      "Composable Conversation Patterns"
    ],
    "Uses": "Automated agent chats, dynamic workflow definition, custom agent behaviors (e.g., nested chat implementation)."
  },
  {
    "Pattern Name": "Control by Fusion of Programming and Natural Language",
    "Problem": "Achieving flexible and powerful control over multi-agent conversation flow, leveraging the strengths of both human-readable natural language instructions and precise programmatic logic.",
    "Context": "Multi-agent systems where LLM-backed agents, human inputs, and tool executions interact, requiring adaptable control mechanisms.",
    "Solution": "Provide natural language control via prompting LLM-backed agents with instructions (e.g., system messages for role-playing, debugging, output confinement). Enable programming language control using code to specify termination conditions, human input modes, tool execution logic, or custom autoreply functions. Support seamless control transition between natural language and code (e.g., LLM inference with control logic in a reply function, LLM-proposed function calls triggering code).",
    "Result": "Enables sophisticated and adaptive control over agent interactions, allowing for dynamic adjustments and complex logic that leverages both human intuition and computational precision.",
    "Related Patterns": [
      "Conversation Programming",
      "Conversable Agents",
      "Unified Conversation Interfaces and Autoreply Mechanisms"
    ],
    "Uses": "Guiding agent behavior, implementing complex decision trees, dynamic debugging, integrating human oversight, LLM function calling."
  },
  {
    "Pattern Name": "Composable Conversation Patterns",
    "Problem": "Building multi-agent applications that require diverse interaction structures (static or dynamic, simple or complex) beyond basic back-and-forth dialogues.",
    "Context": "Designing multi-agent systems for varying application complexities, such as single-turn, multi-turn, human-involved, or dynamically evolving conversations.",
    "Solution": "Provide high-level interfaces for commonly used conversation patterns like Two-Agent Chat, Sequential Chat, Nested Chat, and Group Chat. Allow these patterns to be composed recursively using low-level interfaces (like `register_reply`) to create more complex and creative patterns. Enable dynamic conversation flows through custom reply functions, speaker transition conditions, and LLM-driven function calls.",
    "Result": "Supports a broad spectrum of application needs, from simple two-agent interactions to complex, dynamically evolving multi-agent collaborations, enhancing flexibility and generalizability.",
    "Related Patterns": [
      "Conversation Programming",
      "Unified Conversation Interfaces and Autoreply Mechanisms"
    ],
    "Uses": "Math problem solving (two-agent), retrieval-augmented QA (two-agent), decision making in embodied agents (two/three-agent), supply chain optimization (three-agent), dynamic task solving (group chat), conversational chess (multi-agent); implementing inner monologues or self-reflection (nested chat)."
  },
  {
    "Pattern Name": "Human-in-the-Loop Multi-Agent Systems",
    "Problem": "Effectively integrating human feedback, guidance, and oversight into multi-agent AI workflows to improve performance, ensure safety, and enable collaborative problem-solving.",
    "Context": "Challenging tasks where fully autonomous AI systems may fail, require validation, or where human expertise is essential. Scenarios involving multiple human users collaborating with AI agents.",
    "Solution": "Configure a UserProxyAgent to solicit human inputs at specific rounds or conditions (e.g., `human_input_mode=ALWAYS`). Enable multi-user participation by designing agents (e.g., Student, Expert) that can interact with the system and with each other, mediated by AI assistants.",
    "Result": "Enhances the system's ability to solve complex problems, incorporates human intelligence, provides guardrails, improves user experience, and allows for interactive user instructions and multi-user collaboration.",
    "Related Patterns": [
      "Conversable Agents",
      "Composable Conversation Patterns"
    ],
    "Uses": "Math problem solving (correcting LLM errors, multi-user scenarios), dynamic task solving, conversational games (AI-human chess), general AI oversight."
  },
  {
    "Pattern Name": "Interactive Retrieval",
    "Problem": "Mitigating the intrinsic limitations of LLMs (e.g., hallucination, outdated knowledge, lack of domain-specific context) in retrieval-augmented generation (RAG) systems when initial retrieval is insufficient.",
    "Context": "Question-answering or code generation tasks where LLMs need to access external, up-to-date, or private knowledge bases, and the first attempt to retrieve relevant information might not be enough.",
    "Solution": "Design the LLM-backed assistant to explicitly signal 'UPDATE CONTEXT' when it cannot find information in the current context. This signal triggers a user proxy agent (or another specialized agent) to perform additional retrieval attempts (e.g., fetching next most similar document chunks) and provide updated context to the assistant.",
    "Result": "Dynamically updates the context for the LLM, significantly boosting performance on QA and code generation tasks, and improving the LLM's ability to provide accurate and relevant responses.",
    "Related Patterns": [],
    "Uses": "Natural language question answering, code generation based on private or latest codebases."
  },
  {
    "Pattern Name": "Grounding Agent",
    "Problem": "Preventing LLM-based agents from making commonsense errors, getting stuck in repetitive error loops, or violating task-specific rules in interactive decision-making environments.",
    "Context": "Embodied agents or game-playing AI systems operating in environments that require adherence to physical laws, common sense, or explicit game rules.",
    "Solution": "Introduce a specialized 'grounding agent' that acts as a knowledge source or rule validator. This agent provides crucial commonsense knowledge or checks proposed actions for legality, intervening dynamically (e.g., when recurring errors are detected, or an illegal move is suggested) to guide the decision-making agent.",
    "Result": "Significantly enhances the system's ability to avoid error loops, ensures adherence to rules (e.g., game integrity), and improves decision-making by supplying necessary external knowledge.",
    "Related Patterns": [
      "Executor Agent"
    ],
    "Uses": "Decision making in embodied agents (ALFWorld), conversational games (Chess), preventing flawed plans."
  },
  {
    "Pattern Name": "Adversarial/Collaborative Agent Interactions",
    "Problem": "Ensuring robustness, safety, and quality in complex multi-agent tasks, especially those involving creative generation (like code) where errors or unsafe outputs are possible.",
    "Context": "Tasks requiring a combination of generation, interpretation, and critical review or validation, such as software development or optimization solution interpretation.",
    "Solution": "Design a multi-agent system where some agents work collaboratively to generate solutions (e.g., a 'Writer' for code and interpretation, a 'Commander' for coordination) while others act adversarially to check for safety, errors, or adherence to constraints (e.g., a 'Safeguard' agent for code safety). Information is shared in a controlled manner between these roles.",
    "Result": "Boosts performance (e.g., F1 score in identifying unsafe code), reduces errors, promotes modularity, and ensures a higher quality and safer output.",
    "Related Patterns": [
      "Composable Conversation Patterns"
    ],
    "Uses": "Supply chain optimization (code generation and safety checks), software engineering tasks."
  },
  {
    "Pattern Name": "Executor Agent",
    "Problem": "Decoupling the high-level decision-making and planning logic from the low-level interaction and execution within an external environment.",
    "Context": "Online decision-making tasks where an AI agent needs to perform actions in a simulated or real-world environment (e.g., embodied agents, web interaction tasks).",
    "Solution": "Implement a dedicated 'executor agent' that is responsible for: 1) receiving high-level action decisions from a planning/assistant agent, 2) translating and executing these actions in the environment, and 3) reporting the environment's state, observations, or feedback back to the decision-making agent. The assistant agent then focuses solely on planning and reasoning.",
    "Result": "Simplifies the development of decision-making agents, allows for reuse of planning logic across different environments (with different executors), and streamlines agent-environment interactions by clearly separating concerns.",
    "Related Patterns": [
      "Grounding Agent"
    ],
    "Uses": "Decision making in embodied agents (ALFWorld), online decision making in web interaction tasks (MiniWoB), robotics."
  }
]